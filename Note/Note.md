# 算法学习笔记

## 提高+/省选-

## 做题步骤

1. 读题面，分析题意
2. 看样例，分析样例
3. 看数据范围，根据所给数据范围确定时间复杂度（1s = 10^8）和数据类型
4. 找思路，写代码，本地测试运行，提交

## 算法

### 枚举 & 模拟

枚举的思想是**不断地猜测，从可能的答案集合中一一尝试，然后再判断题目的条件是否成立，枚举每一种可能性**。

要点：

- 找对答案集合
- 答案成立的条件——题目直接给出
- 减小枚举的范围——提高效率
- 选择合适的枚举顺序

模拟的思想是**直接模拟题目中要求的操作来求解**

模拟题目通常具有码量大、操作多的特点。由于码量大，经常出现难以查错的情况。

<span style='color:red'>枚举和模拟有时统称为暴力，不需要做严格区分</span>

### 前缀和 & 差分

**前提：数组每一维均从下标1位置开始存数**

#### 前缀和

前缀和：类似于概念【数组的前`i`项和】，是一种重要的预处理方式

**背景**：

给定一个一维数组，该数组有`n`个元素，现对该数组进行`m`次操作，每次操作给定两个数`l`和`r`，求出数组第`l`个元素到第`r`个元素的和，输入数据如下：

```
4 2
1 2 3 4
1 4
2 3
```

如果使用暴力求解，需要遍历`m`次`n`个元素数组，时间复杂度是`O(m * n)`，想要降低时间复杂度，需要牺牲空间，节省时间，提前进行一些数据计算，减少或消除遍历，其实计算数组第`l`个元素到第`r`个元素的和就是计算前`r`个元素之和与前`l-1`个元素之和的差，可以提前计算前 $ i(1 \leq i \leq n) $个元素的和，消除遍历，时间复杂度为`O(m + n)`

**具体算法实现**：

对于**一维数组**：有`n`个正整数放到数组`ARR[]`中，求一个前缀和数组`sum[]`，其中，`sum[i]`是数组`ARR[]`的第一项到第`i`项和，由此背景，可以推出两个公式:

- `sum[1] = ARR[1]`
- `sum[i] = sum[i - 1] + ARR[i]`

根据这两个公式，可以将前缀和数组中任一一项求出，现在如果要求数组`ARR[]`的第`l`项到第`r`项的和，则可以利用前缀和数组`sum[]`与下列公式快速求出：

**`SUM = sum[r] - sum[l - 1]`**

对于**二维数组**：有`n*m`个正整数放到二维数组`ARR[][]`中，求一个前缀和数组`sum[][]`，其中，`sum[i][j]`是数组`ARR[][]`的第一项和第`i`项围成的矩形区域中所有项的和，如下图所示，

<img src=".\images\前缀和sum[i][j]示意图.png" alt="前缀和sum[i][j]示意图" style="zoom: 50%;" />

由此背景，可以推出两个公式:

**前提：二维数组所有元素全部置0**

- `sum[1][1] = ARR[1][1]`
- `sum[i][j] = sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1] + ARR[i][j]`，如下图所示

<img src=".\images\前缀和sum计算公式示意图.png" alt="前缀和计算公式示意图" style="zoom:50%;" />

根据这两个公式，可以将前缀和数组中任一一项求出，现在如果要求数组`ARR[][]`的第`(x, y)`项到第`(l, r)`项的和，则可以利用前缀和数组`sum[][]`与下列公式快速求出：

**`SUM = sum[l][r] - sum[x - 1][r] - sum[l][y - 1] + sum[x - 1][y - 1]`**，示意图如下：

<img src=".\images\前缀和SUM计算公式示意图.png" style="zoom:50%;" />

前缀和一般用于进行数组预处理，提高后续操作效率，本质上是用空间换时间，多用于计算区间和。

#### 差分

差分是与前缀和相对的策略，本质是求和的逆运算

**背景**：

给定一个一维数组，该数组有`n`个元素，现对该数组进行`m`次操作，每次操作给定两个数`l`和`r`，将数组第`l`个元素到第`r`个元素的每个元素都加1，输入数据如下：

```
4 2
1 2 3 4
1 4
2 3
```

如果使用暴力求解，需要遍历`m`次`n`个元素数组，时间复杂度是`O(m * n)`，想要降低时间复杂度，需要牺牲空间，节省时间，提前进行一些数据计算，减少或消除遍历，考虑给该数组第2个元素加1，那么这个数组的前缀和数组会发生变化，该前缀和数组第2个元素及以后的所有元素都加1，如果给该数组第3个元素减1，那么该前缀和数组第3个元素及以后的所有元素都减1，考虑到此，想要将数组第`l`个元素到第`r`个元素的每个元素都加1，需要把这个数组当作前缀和数组，计算其差分数组，对差分数组的第`l`个元素加1，第`r+1`个元素减1，接着求差分数组的前缀和数组，就可以得到结果。

**具体算法实现**：

给定一个一维前缀和数组`ARR[]`，计算其差分数组`b[]`：

- `b[1] = ARR[1]`
- `b[i] = ARR[i] - ARR[i - 1]`

给定一个二维前缀和数组`ARR[][]`，计算其差分数组`b[][]`：

`b[i][j] = ARR[i][j] - ARR[i - 1][j] - ARR[i][j - 1] + ARR[i - 1][j - 1]`

其实就是前缀和数组的逆运算。

想要实现前缀和数组的`[x, y]`元素到第`[i, j]`元素均加1，对应的差分数组如何操作

```
b[x][y]++;
b[x][j + 1]--;
b[i + 1][y]--;
b[i + 1][j + 1]++;
```

差分多用于区间修改 + 单点查询问题

**概念辨析**：

原数组`arr[]`
差分数组`b[]`：初始时由 a[] 通过差分计算得出，在`b[]`上进行修改操作，最后对`b[]`求前缀和，可得到修改后的`a[]`。
差分标记数组`b[]`：初始时`b[]`的值全部为0，在`b[]`上进行修改操作，然后对`b[]`求前缀和，得到`sum[]1，`sum[i]`是`a[i]`的修改量，在原a[]`上再加上`sum[]`，才可得到修改后的`a[]`。

### 尺取法

尺取法（滑动窗口/双指针法）：一种利用**双指针遍历**获取满足条件的区间（滑动窗口）的算法，其为一种线性算法。

**条件**：

区间权值和（区间中各个元素之和）随区间长度**单调不减或单调不增**，即当一个边界固定时，区间越长区间权值和越小或越大，那么要求数组中所有元素为非负数或者非正数。

算法过程为：

### 离散化

### 二分

P1083
